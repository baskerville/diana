#! /usr/bin/env python2
# -*- coding: utf-8 -*-

import urllib2, json, base64
import sys, os
from subprocess import check_call
from getopt import getopt

MAX_NAME_LEN = 50
ELLIPSIS = '...'
HASHES_FILE = os.path.expandvars('$XDG_DATA_HOME/aria2hashes')
PREVIEW_COMMAND = 'open'

def abbrev (value):
    n = value / 1024.0
    if n < 1:
        return '%dB' % value
    value = n
    n = value / 1024.0
    if n < 1:
        return '%.1fK' % value
    else:
        value = n;
        n = value / 1024.0
        if n < 1:
            return '%.1fM' % value
        else:
            return '%.1fG' % n

def arrival (download_speed, remaining_length):
    if (download_speed == 0): return 'n/a'
    s = remaining_length / download_speed
    h = s / 3600
    s = s % 3600
    m = s / 60
    s = s % 60
    result = ""
    if (h >= 1): result += '%dh' % h
    if (m >= 1): result += '%dm' % m
    result += "%ds" % s
    return result

def call_func(func, params=[]):
    jsonreq = json.dumps({'id':'foo', 'method':'aria2.%s' % func, 'params':params})
    try:
        c = urllib2.urlopen('http://localhost:6800/jsonrpc', jsonreq)
    except:
        print >> sys.stderr, sys.exc_info()
        exit(1)
    response = json.loads(c.read())
    return response

def get_active():
    return call_func('tellActive')

def get_waiting():
    return call_func('tellWaiting', [0, 666])

def get_stopped():
    return call_func('tellStopped', [0, 666])

def get_files(gids):
    for g in gids:
        response = call_func('getFiles', [g])
        if not response:
            print 'failed on %s' % g
        else:
            if len(gids) > 1:
                print '%s: ' % g
            files = response['result']
            for f in files:
                total_length = float(f['length'])
                completed_length = float(f['completedLength'])
                percent = 100;

                if (total_length > 0):
                    percent = 100 * completed_length / total_length

                percent = '%.1f' % percent
                selected = f['selected']
                mark = '[ ]'

                if selected == 'true':
                    mark = '[X]'

                print '%s %2s %5s%% %s' % (mark, f['index'], percent, f['path'])

def apply_func_on_gids(fn, gids):
    for g in gids:
        response = call_func(fn, [g])
        if not response:
            print 'failed on %s' % g

def preview_by_gid(gids):
    for g in gids:
        response = call_func('getFiles', [g])
        if not response:
            print 'failed on %s' % g
        else:
            if len(gids) > 1:
                print '%s: ' % g
            files = response['result']
            for f in files:
                completed_length = float(f['completedLength'])
                if completed_length > 0:
                    check_call([PREVIEW_COMMAND, f['path']])

def pause_by_gid(gids):
    apply_func_on_gids('pause', gids)

def resume_by_gid(gids):
    apply_func_on_gids('unpause', gids)

def remove_by_gid(gids):
    apply_func_on_gids('remove', gids)

def clean():
    downloads = []
    active = get_active()
    if active:
        downloads.extend(active['result'])
    for d in downloads:
        if d.has_key('infoHash'):
            completed_length = int(d['completedLength'])
            total_length = int(d['totalLength'])
            if completed_length >= total_length:
                remove_by_gid([d['gid']])

        
def add_items(items, options={}):
    for item in items:
        response = None

        if item.find('://') != -1:
            response = call_func('addUri', [[item]])
        else:
            item_content = base64.b64encode(open(item).read())
            if item.endswith('.torrent'):
                response = call_func('addTorrent', [item_content, [], options])
            elif item.endswith('.meta4') or item.endswith('.metalink'):
                response = call_func('addMetalink', [item_content])

        if not response:
            print 'failed on %s' % item
        else:
            print response['result']

def save_kill():
    hf = open(HASHES_FILE, 'w')
    downloads = []
    active = get_active()
    paused = get_waiting()
    if active:
        downloads.extend(active['result'])
    if paused:
        downloads.extend(paused['result'])
    for d in downloads:
        if d.has_key('infoHash'):
            gid = d['gid']
            infoHash = d['infoHash']
            status = d['status']
            if status == 'paused':
                infoHash = '_%s' % infoHash
            response = call_func('getFiles', [gid])
            if response:
                files = response['result']
                selection = []
                for f in files:
                    index = f['index']
                    selected = f['selected']
                    if selected == 'true':
                        selection.append(index)
                select_file_argument = ','.join(selection)
                hf.write('%s:%s\n' % (infoHash, select_file_argument))
    hf.close()
    call_func('shutdown')

def pause_all():
    call_func('pauseAll')

def resume_all():
    call_func('unpauseAll')

def list_downloads(kind):
    downloads = None

    if kind == 'active':
        downloads = get_active()
    elif kind == 'waiting':
        downloads = get_waiting()
    elif kind == 'stopped':
        downloads = get_stopped()

    if downloads:
        for r in downloads['result']:
            completed_length = float(r['completedLength'])
            total_length = float(r['totalLength'])
            remaining_length = total_length - completed_length
            download_speed = float(r['downloadSpeed'])
            eta = arrival(download_speed, remaining_length)
            percent = 100;

            if (total_length > 0):
                percent = 100 * completed_length / total_length

            percent = '%.1f' % percent
            byte_download_speed = '%.1f' % (download_speed / 1024)
            byte_upload_speed = '%.1f' % (float(r['uploadSpeed']) / 1024)
            name = 'n/a'
            number_of_seeders = 'n/a'

            if r.has_key('numSeeders'):
                number_of_seeders = r['numSeeders']

            if r.has_key('bittorrent'):
                bt = r['bittorrent']
                if bt.has_key('info'):
                    name = bt['info']['name']

            if len(name) > MAX_NAME_LEN: name = name[:MAX_NAME_LEN - len(ELLIPSIS)] + ELLIPSIS

            print "%3s %-50s\t%5s%%\t%6s\t%6s\t%5s\t%5s\t%s/%s\t%s" % (r['gid'], name, percent, abbrev(completed_length), abbrev(total_length), byte_download_speed, byte_upload_speed, number_of_seeders, r['connections'], eta)

def show_errors():
    stopped = get_stopped()
    if stopped:
        for r in stopped['result']:
            if r.has_key('status'):
                status = r['status']
                if status == 'error':
                    gid = r['gid']
                    errorCode = r['errorCode']
                    error = EXIT_CODES[errorCode]
                    print '%3s %s' % (gid, error)

def usage():
    print '''usage: %s <action> [arguments]

       ACTIONS 
            list
            paused
            stopped
            errors
            sleep
            wake
            purge
            clean
            kill
            add [--select-file=a-b,d-e,...] item1 [item2 ...],
            remove gid1 [gid2 ...],
            pause gid1 [gid2 ...],
            resume gid1 [gid2 ...],
            files gid1 [gid2 ...],
            preview gid1 [gid2 ...]''' % os.path.basename(sys.argv[0])
    sys.exit()


def main():
    opts, args = getopt(sys.argv[1:], 'h', ['help', 'select-file='])
    options = {}

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
        else:
            options.update({o.replace('--',''):a})

    if len(args) > 0:
        action = args[0]
        arguments = args[1:]
        if action in NO_ARGS_ACTIONS and len(arguments) > 0:
            print >> sys.stderr, 'action \'%s\' takes no arguments' % action
            sys.exit(1)

        if action == 'add':
            add_items(arguments, options)
        elif action == 'remove':
            remove_by_gid(arguments)
        elif action == 'preview':
            preview_by_gid(arguments)
        elif action == 'pause':
            pause_by_gid(arguments)
        elif action == 'resume':
            resume_by_gid(arguments)
        elif action == 'files':
            get_files(arguments)
        elif action == 'list':
            list_downloads('active')
        elif action == 'errors':
            show_errors()
        elif action == 'paused':
            list_downloads('waiting')
        elif action == 'stopped':
            list_downloads('stopped')
        elif action == 'sleep':
            call_func('pauseAll')
        elif action == 'wake':
            call_func('unpauseAll')
        elif action == 'purge':
            call_func('purgeDownloadResult')
        elif action == 'clean':
            clean()
        elif action == 'kill':
            save_kill()
        else:
            print >> sys.stderr, 'unknown action: %s' % action
            exit(1)
    else:
        usage()

NO_ARGS_ACTIONS = ('list', 'paused', 'stopped', 'errors', 'sleep', 'wake', 'purge', 'clean', 'kill')

EXIT_CODES = {
              '1':'unknown',
              '2':'timeout',
              '3':'resource not found',
              '4':'resources not found',
              '5':'download speed too slow',
              '6':'network problem',
              '7':'unfinished downloads',
              '8':'resume not supported',
              '9':'not enough disk space',
              '10':'piece length differ',
              '11':'was downloading the same file',
              '12':'was downloading the same info hash',
              '13':'file already existed',
              '14':'renaming failed',
              '15':'could not open existing file',
              '16':'could not create new or truncate existing',
              '17':'file I/O',
              '18':'could not create directory',
              '19':'name resolution failed',
              '20':'could not parse metalink',
              '21':'FTP command failed',
              '22':'HTTP response header was bad or unexpected',
              '23':'too many redirections',
              '24':'HTTP authorization failed',
              '25':'could not parse bencoded file',
              '26':'torrent was corrupted or missing informations',
              '27':'bad magnet URI',
              '28':'bad/unrecognized option or unexpected option argument',
              '29':'the remote server was unable to handle the request',
              '30':'could not parse JSON-RPC request'
             }

if __name__ == '__main__':
    main()
