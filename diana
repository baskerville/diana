#! /usr/bin/env python
# -*- coding: utf-8 -*-

import urllib.request, json, base64
from urllib.error import URLError, HTTPError
import sys, os
import re
from subprocess import check_call
from getopt import getopt

MAX_NAME_LEN = 50
ELLIPSIS = '...'
HASHES_FILE = os.path.expandvars('$XDG_DATA_HOME/aria2hashes')
PREVIEW_COMMAND = 'open'

def abbrev (value):
    n = value / 1024.0
    if n < 1:
        return '%dB' % value
    value = n
    n = value / 1024.0
    if n < 1:
        return '%.1fK' % value
    else:
        value = n;
        n = value / 1024.0
        if n < 1:
            return '%.1fM' % value
        else:
            return '%.1fG' % n

def arrival (download_speed, remaining_length):
    if (download_speed == 0): return 'n/a'
    s = remaining_length / download_speed
    h = s / 3600
    s = s % 3600
    m = s / 60
    s = s % 60
    result = ""
    if (h >= 1): result += '%dh' % h
    if (m >= 1): result += '%dm' % m
    result += "%ds" % s
    return result

def call_func(func, params=[]):
    jsonreq = json.dumps({'id' : 'foo', 'method' : 'aria2.%s' % func, 'params' : params}).encode('utf-8')
    try:
        c = urllib.request.urlopen('http://localhost:6800/jsonrpc', jsonreq)
    except IOError as err:
        code = -1
        if type(err) is URLError:
            code = err.reason.errno
        elif type(err) is HTTPError:
            code = err.code
        if code == 111:
            print('the daemon is not running', file = sys.stderr)
        elif code == -1:
            print('encountered an error of type: %s' % type(err), file = sys.stderr)
        else:
            print('server replied: %s' % code, file = sys.stderr)
        exit(1)
    data = c.read().decode('utf-8')
    response = json.loads(data)
    return response

def get_active():
    return call_func('tellActive')

def get_waiting():
    return call_func('tellWaiting', [0, 666])

def get_stopped():
    return call_func('tellStopped', [0, 666])

def get_files(gids):
    for g in gids:
        response = call_func('getFiles', [g])
        if not response:
            print('failed on %s' % g)
        else:
            if len(gids) > 1:
                print('%s: ' % g)
            files = response['result']
            for f in files:
                total_length = float(f['length'])
                completed_length = float(f['completedLength'])
                percent = 100;

                if (total_length > 0):
                    percent = 100 * completed_length / total_length

                percent = '%.1f' % percent
                selected = f['selected']
                mark = '[ ]'

                if selected == 'true':
                    mark = '[X]'

                print('%s %2s %5s%% %s' % (mark, f['index'], percent, f['path']))

def apply_func_on_gids(fn, gids):
    for g in gids:
        response = call_func(fn, [g])
        if not response:
            print('failed on %s' % g)

def pattern_match(index, pattern):
    for p in pattern:
        if len(p) > 1:
            first = int(p[0])
            second = int(p[1])
            if index >= first and index <= second:
                return True
        else:
            first = int(p[0])
            if index == first:
                return True
    return False

def preview_by_gid(gids, options):
    select_file = []
    if 'select-file' in options:
        select_file = [re.split('-', x) for x in re.split(',', options['select-file'])]

    for g in gids:
        response = call_func('getFiles', [g])
        if not response:
            print('failed on %s' % g)
        else:
            if len(gids) > 1:
                print('%s: ' % g)
            files = response['result']
            for f in files:
                if len(select_file) > 0:
                    index = int(f['index'])
                    if not pattern_match(index, select_file):
                        continue
                completed_length = float(f['completedLength'])
                if completed_length > 0:
                    check_call([PREVIEW_COMMAND, f['path']])

def pause_by_gid(gids):
    apply_func_on_gids('pause', gids)

def resume_by_gid(gids):
    apply_func_on_gids('unpause', gids)

def remove_by_gid(gids):
    apply_func_on_gids('remove', gids)

def clean():
    downloads = []
    active = get_active()
    if active:
        downloads.extend(active['result'])
    for d in downloads:
        if 'infoHash' in d:
            completed_length = int(d['completedLength'])
            total_length = int(d['totalLength'])
            if completed_length >= total_length:
                remove_by_gid([d['gid']])

def add_items(items, options={}):
    for item in items:
        response = None

        if item.find('://') != -1:
            response = call_func('addUri', [[item], options])
        else:
            item_content = base64.b64encode(open(item, 'rb').read()).decode('utf-8')
            if item.endswith('.torrent'):
                response = call_func('addTorrent', [item_content, [], options])
            elif item.endswith('.meta4') or item.endswith('.metalink'):
                response = call_func('addMetalink', [item_content, options])

        if not response:
            print('failed on %s' % item)
        else:
            print(response['result'])

def save_kill():
    hf = open(HASHES_FILE, 'w')
    downloads = []
    active = get_active()
    paused = get_waiting()
    if active:
        downloads.extend(active['result'])
    if paused:
        downloads.extend(paused['result'])
    for d in downloads:
        if 'infoHash' in d:
            gid = d['gid']
            infoHash = d['infoHash']
            status = d['status']
            if status == 'paused':
                infoHash = '_%s' % infoHash
            response = call_func('getFiles', [gid])
            if response:
                files = response['result']
                selection = []
                for f in files:
                    index = f['index']
                    selected = f['selected']
                    if selected == 'true':
                        selection.append(index)
                select_file_argument = ','.join(selection)
                hf.write('%s:%s\n' % (infoHash, select_file_argument))
    hf.close()
    call_func('shutdown')

def pause_all():
    call_func('pauseAll')

def resume_all():
    call_func('unpauseAll')

def list_downloads(kind):
    downloads = None

    if kind == 'active':
        downloads = get_active()
    elif kind == 'waiting':
        downloads = get_waiting()
    elif kind == 'stopped':
        downloads = get_stopped()

    if downloads:
        for r in downloads['result']:
            completed_length = float(r['completedLength'])
            total_length = float(r['totalLength'])
            remaining_length = total_length - completed_length
            download_speed = float(r['downloadSpeed'])
            eta = arrival(download_speed, remaining_length)
            percent = 100;

            if (total_length > 0):
                percent = 100 * completed_length / total_length

            percent = '%.1f' % percent
            byte_download_speed = '%.1f' % (download_speed / 1024)
            byte_upload_speed = '%.1f' % (float(r['uploadSpeed']) / 1024)
            name = 'n/a'
            number_of_seeders = 'n/a'

            if 'numSeeders' in r:
                number_of_seeders = r['numSeeders']

            if 'bittorrent' in r:
                bt = r['bittorrent']
                if 'info' in bt:
                    name = bt['info']['name']

            if len(name) > MAX_NAME_LEN: name = name[:MAX_NAME_LEN - len(ELLIPSIS)] + ELLIPSIS

            output_line = "%3s %-50s\t%5s%%\t%6s\t%6s\t%5s\t%5s\t%s/%s\t%s" % (r['gid'], name, percent, abbrev(completed_length), abbrev(total_length), byte_download_speed, byte_upload_speed, number_of_seeders, r['connections'], eta)

            if sys.stdout.isatty():
                if completed_length >= total_length:
                    output_line = green(output_line)
                elif download_speed > 0:
                    output_line = blue(output_line)

            print(output_line)

def green(s):
    return '\033[1;32m%s\033[0m' % s

def blue(s):
    return '\033[1;34m%s\033[0m' % s

def show_errors():
    stopped = get_stopped()
    if stopped:
        for r in stopped['result']:
            if 'status' in r:
                status = r['status']
                if status == 'error':
                    gid = r['gid']
                    errorCode = r['errorCode']
                    error = EXIT_CODES[errorCode]
                    print('%3s %s' % (gid, error))

def usage():
    print('''
SYNOPSIS
    %s <action> [arguments]

ACTIONS 
    list
        Show the list of active downloads.

    paused
        Show the list of paused downloads.

    stopped
        Show the list of stopped downloads.

    errors
        Show the list of encountered errors.

    sleep
        Pause all the active downloads.

    wake
        Resume all the paused downloads.

    purge
        Clear the list of stopped downloads and errors.

    clean
        Stop seeding completed downloads.

    kill
        Kill the daemon.

    add [--select-file=...] ITEM ...
        Download the given items (local or remote URLs to torrents, etc.).

    remove GID ...
        Remove the downloads corresponding to the given GIDs.

    pause GID ...
        Pause the downloads corresponding to the given GIDs.

    resume GID
        Resume the downloads corresponding to the given GIDs.

    files GID ...
        Show the files owned by the downloads corresponding to the given GIDs.

    preview [--select-file=...] GID ...
        Preview all the files from all the downloads corresponding to the given GIDs.

    ''' % os.path.basename(sys.argv[0]))
    sys.exit()


def main():
    opts, args = getopt(sys.argv[1:], 'h', ['help', 'out=', 'header=', 'select-file='])
    options = {}

    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
        else:
            options.update({o.replace('--',''):a})

    if len(args) > 0:
        action = args[0]
        arguments = args[1:]

        if action in NO_ARGS_ACTIONS and len(arguments) > 0:
            print('action \'%s\' takes no arguments' % action, file=sys.stderr)
            sys.exit(1)
        elif action in ARGS_ACTIONS and len(arguments) < 1:
            print('no arguments given for action \'%s\'' % action, file=sys.stderr)
            sys.exit(1)

        if action == 'add':
            add_items(arguments, options)
        elif action == 'remove':
            remove_by_gid(arguments)
        elif action == 'preview':
            preview_by_gid(arguments, options)
        elif action == 'pause':
            pause_by_gid(arguments)
        elif action == 'resume':
            resume_by_gid(arguments)
        elif action == 'files':
            get_files(arguments)
        elif action == 'list':
            list_downloads('active')
        elif action == 'errors':
            show_errors()
        elif action == 'paused':
            list_downloads('waiting')
        elif action == 'stopped':
            list_downloads('stopped')
        elif action == 'sleep':
            call_func('pauseAll')
        elif action == 'wake':
            call_func('unpauseAll')
        elif action == 'purge':
            call_func('purgeDownloadResult')
        elif action == 'clean':
            clean()
        elif action == 'kill':
            save_kill()
        else:
            print('unknown action: %s' % action, file=sys.stderr)
            exit(1)
    else:
        usage()

NO_ARGS_ACTIONS = ('list', 'paused', 'stopped', 'errors', 'sleep', 'wake', 'purge', 'clean', 'kill')
ARGS_ACTIONS = ('add', 'remove', 'preview', 'pause', 'resume', 'files')

EXIT_CODES = {
              '1':'unknown',
              '2':'timeout',
              '3':'resource not found',
              '4':'resources not found',
              '5':'download speed too slow',
              '6':'network problem',
              '7':'unfinished downloads',
              '8':'resume not supported',
              '9':'not enough disk space',
              '10':'piece length differ',
              '11':'was downloading the same file',
              '12':'was downloading the same info hash',
              '13':'file already existed',
              '14':'renaming failed',
              '15':'could not open existing file',
              '16':'could not create new or truncate existing',
              '17':'file I/O',
              '18':'could not create directory',
              '19':'name resolution failed',
              '20':'could not parse metalink',
              '21':'FTP command failed',
              '22':'HTTP response header was bad or unexpected',
              '23':'too many redirections',
              '24':'HTTP authorization failed',
              '25':'could not parse bencoded file',
              '26':'torrent was corrupted or missing informations',
              '27':'bad magnet URI',
              '28':'bad/unrecognized option or unexpected option argument',
              '29':'the remote server was unable to handle the request',
              '30':'could not parse JSON-RPC request'
             }

if __name__ == '__main__':
    main()
